// Integrantes: Aguerrondo, Carballo, Martin
// Abril 2019 UCU

/*** BeginHeader */
// Definicion de macros
#define MAX_EVENTS 16

// Definicion de estructuras
typedef struct {		// Struct de eventos
	char command;
	char param;
	unsigned long time;
} Event;

// Definicion de variables
Event eventos[MAX_EVENTS];		// Lista de Eventos GLOBAL

/*** EndHeader */




//// Metodos

/*** BeginHeader  posicionLibre */
void posicionLibre( int *p_posicion );
/*** EndHeader */
void posicionLibre( int *p_posicion ){  	// Devuelve primer posicion libre del array de eventos
	int i;
	OSSchedLock();

	for ( i = 0 ; i < MAX_EVENTS ; i++ ){
		if (eventos[i].command == 0xFF){
			*p_posicion = i;
			return;
		}
	}
	OSSchedUnlock();

	// Si no salio por el for es que no hay mas lugar. Retorno -1
	*p_posicion = -1;
	return;
}

/*** BeginHeader EVENTOS_Eventos_init */
void EVENTOS_Eventos_init();
/*** EndHeader */
void EVENTOS_Eventos_init(){
	int i;
			OSSchedLock();

	for (i=0;i<MAX_EVENTS;i++){
		eventos[i].command = 0xFF;
      eventos[i].param = 0xFF;
	}
	OSSchedUnlock();
	printf("\nEventos iniciados correctamente");
}



/*** BeginHeader EVENTOS_agregarEvento */
void EVENTOS_agregarEvento( Event *p_tempevento);
/*** EndHeader */
void EVENTOS_agregarEvento( Event *p_tempevento)
{
	int posicion;
	//Event evento;
	posicionLibre( &posicion );
	//printf("\nDEBUG: Posicion libre encontrada: %d", posicion );
	if (posicion == -1){
		printf("\nERROR: No se puede ingresar evento, calendario lleno.");
	}
	else{
		//evento = eventos[posicion];
		OSSchedLock();
		eventos[posicion].command = p_tempevento->command;
		eventos[posicion].param = p_tempevento->param;
		eventos[posicion].time = p_tempevento->time;
		OSSchedUnlock();
		printf("\nINFO: Evento AGREGADO correctamente");
	}
}

/*** BeginHeader EVENTOS_eliminarEvento */
void EVENTOS_eliminarEvento( int posicionEvento );
/*** EndHeader */
void EVENTOS_eliminarEvento( int posicionEvento ){
	OSSchedLock();
	eventos[posicionEvento].command = 0xFF;
	eventos[posicionEvento].param = 0xFF;
		OSSchedUnlock();
	printf("\nINFO: Evento %d eliminado correctamente.", posicionEvento);
}

/*** BeginHeader EVENTOS_listarEventos */
void EVENTOS_listarEventos();
/*** EndHeader */
void EVENTOS_listarEventos(){
	int i;
	OSSchedLock();
	for ( i=0; i<MAX_EVENTS; i++ ){
		printf("\n------------------------------\n");
		if ( eventos[i].command != 0xFF ){
			// Metemos en el buffer el texto formateado
			//sprintf( bufferText,"\n----------------------------------------:\nNUMERO DE EVENTO: %d\n", i + 1" );
			//UT_printEvento( &eventos[i] );
			printf("Numero de Evento: %d\n",i+1 );
			printf("Command: %d\n",eventos[i].command );
			printf("Command: %d\n",eventos[i].param );
			printf("Command: %d\n",eventos[i].time ); // ver para immprimir lindo
		}

	}
	OSSchedUnlock();
}

/*** BeginHeader EVENTOS_ejecutarEventos */
void EVENTOS_ejecutarEventos();
/*** EndHeader */
void EVENTOS_ejecutarEventos(){
	int i, comando;

	for ( i=0; i<MAX_EVENTS; i++ ){
		if (eventos[i].command != 0xFF){

			// verifico hora del evento comparando con el timestamp de la hora actual
			if ( eventos[i].time < RTC_leerTimestamp() )  {

				// Verifico el tipo de evento
				comando = eventos[i].command  - '0';
				//printf("\nDEBUG: El comando es %u", comando);
				switch( comando ){
					case( OPCION_1 ):
						printf("\nDEBUG: Evento PRENDER LED");
						LED_SET( eventos[i].param );
						break;

					case( OPCION_2 ):
						printf("\nDEBUG: Evento APAGAR LED");
						LED_RESET( eventos[i].param );
						break;
				}
				EVENTOS_eliminarEvento(i); // Borro el elemento
			}
		}
	}
}