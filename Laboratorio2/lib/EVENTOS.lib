/*** BeginHeader */
// Definicion de macros
#define MAX_EVENTS 5

// Definicion de estructuras
typedef struct {		// Struct de eventos
	char command;
	char param;
	unsigned long time;
} Event;

// Definicion de variables
Event eventos[MAX_EVENTS];		// Lista de Eventos
/*** EndHeader */

/*** BeginHeader  posicionLibre */
int posicionLibre();
/*** EndHeader */

//// Metodos
int posicionLibre(){  	// Devuelve primer posicion libre del array de eventos
	int i;
	for (i=0;i<MAX_EVENTS;i++){
		if (eventos[i].command == 0xFF){
			return i;
		}
	}
	if (i==MAX_EVENTS-1){	// Indica que el array esta lleno
		return -1;
	}

}

/*** BeginHeader EVENTOS_initEventos*/
void EVENTOS_initEventos();
/*** EndHeader */
void EVENTOS_initEventos(){
	int i;
	for (i=0;i<MAX_EVENTS;i++){
		eventos[i].command = 0xFF;
      eventos[i].param = 0xFF;
	}
	printf("\nEventos iniciados correctamente");
}


/*** BeginHeader EVENTOS_agregarEvento */
void EVENTOS_agregarEvento( Event *p_evento);
/*** EndHeader */
void EVENTOS_agregarEvento( Event *p_evento)
{
	int posicion;
   Event e;
	posicion = posicionLibre() ;
	if (posicion == -1){
		printf("\nERROR: No se puede ingresar evento, calendario lleno.");
	}else{
      e = eventos[posicion];
		e.command = (*p_evento).command;
      e.param = (*p_evento).param;
      e.time = (*p_evento).time;
		printf("\nEvento AGREGADO correctamente");
	}
}

/*** BeginHeader EVENTOS_eliminarEvento */
void EVENTOS_eliminarEvento();
/*** EndHeader */
void EVENTOS_eliminarEvento(int posicionEvento){
	eventos[posicionEvento].command = 0xFF;
}

/*** BeginHeader EVENTOS_listarEventos */
void EVENTOS_listarEventos();
/*** EndHeader */
void EVENTOS_listarEventos(){
	int i, j, int_item;
	struct tm *p_FechaHora;
   char unChar;

	j = 1;

	for (i=0;i<MAX_EVENTS;i++){
		printf("\n----------------------------------------:\n" );
		printf("NUMERO DE EVENTO %d:\n", j);

      int_item = atoi(&eventos[i].command);
      //unChar = UT_ASCIItoCharNum( eventos[i].command );  esto parece que no anda
      printf("COMANDO: %d\n", int_item);

      int_item = atoi(&eventos[i].param);
		printf("LED : %d\n", int_item);

      mktm( p_FechaHora, eventos[i].time );
		printf("HORA:\n");
      printFechaHora( p_FechaHora );

		j++;
	}
}

/*** BeginHeader EVENTOS_ejecutarEventos */
void EVENTO_ejecutarEventos();
/*** EndHeader */
void EVENTO_ejecutarEventos(){
	int i;
	for (i=0;i<MAX_EVENTS;i++){
		if (eventos[i].command != 0xFF){

			// verifico hora
			if (eventos[i].time < RTC_leerFechaHora)  { /// LA COMPARACION ESTA MAL REALIZARLA BIEN CON EL STRUC CORREPONDIENTE
														/// DEBE COMPARAR SI LA FECHA DEL EVENTO ES MAS CHICA QUE LA ACTUAL PARA EJECUTAR EL COMANDO
				// verifico si debe encender o apagar el led
				if (eventos[i].command == 0){
					LED_RESET(eventos[i].param);
				}else{
					LED_SET(eventos[i].param);
				}
				EVENTOS_eliminarEvento(i); // Borro el elemento
			}
		}
	}
	printf("No hay mas Eventos\n");
}