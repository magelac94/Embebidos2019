// Menu por TCP
/* Esta tarea escucha por una conexion entrante por el puerto 7.
Cuando hay una conexion activa, muestra el menu por la interfaz tcp.
Debemos asignarle un stack de 2K por el socket tcp.
*/
/*** BeginHeader TCP1_tarea_interfaz_tcp*/
void TCP1_tarea_interfaz_tcp(void* pdata);
/*** EndHeader */
void TCP1_tarea_interfaz_tcp(void* pdata){

	struct tm FechaHora;
	char buffer[TAMANIO_BUFFER_LE];
	tcp_Socket* pun_tcp_socket;
	CHECKPOINT unCheckpoint;
	auto int int_opcion_menu, int_id_checkpoint;
	auto INT8U Error;

	pun_tcp_socket = (tcp_Socket*)pdata;

	while(1) {
		// Ponemos el socket en estado de escucha
		if (!tcp_listen(pun_tcp_socket, LPORT, 0, 0, NULL, 0)){
#ifdef DEBUG
		printf("\nDEBUG: Error al abrir el socket\n");
#endif
		}
		// Inicializamos buffer para sacar la basura
		memset(buffer, " ", sizeof(buffer));

      // Le damos un tiempo para que el socket quede pronto
		OSTimeDlyHMSM(0,0,0,500);
#ifdef DEBUG
		printf("\nDEBUG: Escuchando en puerto %u por conexiones\n", LPORT );
#endif
		// Esperamos por la conexion y si no esta establecida y pronta, suspende por 500ms.
		while( !sock_established(pun_tcp_socket) ) { // && sock_bytesready(pun_tcp_socket)==-1
			tcp_tick(pun_tcp_socket);
			OSTimeDlyHMSM(0,0,0,500);
		}
		// Un delay para que se establezca la conexion
		OSTimeDlyHMSM(0,0,0,500);

		if (sock_established(pun_tcp_socket)){
#ifdef DEBUG
			printf("\nDEBUG: Conexion establecida\n");
#endif
			sock_mode(pun_tcp_socket, TCP_MODE_ASCII);
			do {

				// Se muestra menu y se espera opcion
				MENU_mostrarMenuPrincipal( TCP, buffer, pun_tcp_socket );
				MENU_obtenerOpcion( TCP, buffer, pun_tcp_socket );
				int_opcion_menu = atoi( buffer );
#ifdef DEBUG
				printf("\nDEBUG: MAIN: Opcion elegida: %u\n", int_opcion_menu );
#endif
				switch( int_opcion_menu ){
					case( OPCION_1 ):
						// CONSULTAR FECHA HORA ACTUAL
						MENU_consultarHora( TCP, buffer, pun_tcp_socket );
						RTC_leerFechaHora( &FechaHora );	// Leo el RTC
						MENU_printFechaHora( TCP, &FechaHora, buffer, pun_tcp_socket ); // Imprimo la Fecha y hora
						break;

					case( OPCION_2 ):
						// AGREGAR UN CHECKPOINT
						MENU_pedirDatosCheckpoint( TCP, &unCheckpoint, buffer, pun_tcp_socket );
						CHECKPOINT_agregarCheckpoint( &unCheckpoint );
						break;

					case ( OPCION_3 ):
						// ELIMINAR UN CHECKPOINT (ES DE 1 EN adelante segun posicion en el array))
						int_id_checkpoint = MENU_eliminarCheckpoint( TCP, buffer, pun_tcp_socket );
						CHECKPOINT_eliminarCheckpoint( int_id_checkpoint );
						break;

					case( OPCION_4 ):
						// CONFIGURAR DISTANCIA AL CHECKPOINT
						MENU_configurarDistanciaCheckpoint( TCP, buffer, pun_tcp_socket );
						CHECKPOINT_configurarDistancia();
						break;
					
					case( OPCION_5 ):
						// LISTAR CHECKPOINTS CONFIGURADOS
						MENU_listarCheckpoints( TCP, buffer, pun_tcp_socket );
						break;
					
					case( OPCION_6 ):
						// CONFIGURAR ID DE PARTICIPANTE
						MENU_configurarIDParticipante( TCP, buffer, pun_tcp_socket );
						//ACA una funcion que setee ese valor GLOBAL
						break;
						
					case( OPCION_7 ):
						// CONFIGURAR RANGO DE RITMO CARDIACO
						MENU_configurarRC( TCP, buffer, pun_tcp_socket );
						//ACA Alguna funcion del la libreria SALUD
						break;
					
					case( OPCION_8 ):
						// CONFIGURAR TIEMPO DE INACTIVIDAD
						MENU_configurarInactividad( TCP, buffer, pun_tcp_socket );
						//ACA Alguna funcion del la libreria SALUD
						break;
						
					default:
						// OPCION INCORRECTA
						printf("\nA IMPLEMENTAR: Mandar este mensaje a la interfaz correcta: Opcion DEFAULT: %d \n", int_opcion_menu);
						printf("A IMPLEMENTAR: Mandar este mensaje a la interfaz correcta: Vuelva a ingresar\n");
						OSTimeDlyHMSM(0,0,0,500);
				}
				OSTimeDlyHMSM(0,0,0,500);
			} while(tcp_tick(pun_tcp_socket));
		}
#ifdef DEBUG
		printf("\nDEBUG: Conexion finalizada....\n");
#endif

	}
}